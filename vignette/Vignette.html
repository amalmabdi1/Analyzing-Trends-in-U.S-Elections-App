<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Group AOS – DATA-413">
<meta name="dcterms.date" content="2025-12-09">

<title>Exploring U.S. Elections and Public Opinion (1976–2020)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Vignette_files/libs/clipboard/clipboard.min.js"></script>
<script src="Vignette_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Vignette_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Vignette_files/libs/quarto-html/popper.min.js"></script>
<script src="Vignette_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Vignette_files/libs/quarto-html/anchor.min.js"></script>
<link href="Vignette_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Vignette_files/libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Vignette_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Vignette_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Vignette_files/libs/bootstrap/bootstrap-8a894fcc3cb5e37eb5bf30def131be2f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#usage-purposes-and-overview" id="toc-usage-purposes-and-overview" class="nav-link active" data-scroll-target="#usage-purposes-and-overview"><span class="header-section-number">1</span> Usage Purposes and Overview</a></li>
  <li><a href="#required-packages-and-environment" id="toc-required-packages-and-environment" class="nav-link" data-scroll-target="#required-packages-and-environment"><span class="header-section-number">2</span> Required Packages and Environment</a></li>
  <li><a href="#data-sources-and-structure" id="toc-data-sources-and-structure" class="nav-link" data-scroll-target="#data-sources-and-structure"><span class="header-section-number">3</span> Data Sources and Structure</a></li>
  <li><a href="#running-code" id="toc-running-code" class="nav-link" data-scroll-target="#running-code"><span class="header-section-number">4</span> Running Code</a></li>
  <li><a href="#basic-structure" id="toc-basic-structure" class="nav-link" data-scroll-target="#basic-structure"><span class="header-section-number">5</span> Basic Structure</a></li>
  <li><a href="#exploratory-data-analysis-eda-with-the-app" id="toc-exploratory-data-analysis-eda-with-the-app" class="nav-link" data-scroll-target="#exploratory-data-analysis-eda-with-the-app"><span class="header-section-number">6</span> Exploratory Data Analysis (EDA) with the App</a></li>
  <li><a href="#image" id="toc-image" class="nav-link" data-scroll-target="#image"><span class="header-section-number">7</span> Image</a></li>
  <li><a href="#statistical-analysis-inputs-models-and-interpretation" id="toc-statistical-analysis-inputs-models-and-interpretation" class="nav-link" data-scroll-target="#statistical-analysis-inputs-models-and-interpretation"><span class="header-section-number">8</span> Statistical Analysis: Inputs, Models, and Interpretation</a></li>
  <li><a href="#literature-review-sources" id="toc-literature-review-sources" class="nav-link" data-scroll-target="#literature-review-sources"><span class="header-section-number">9</span> Literature Review (Sources)</a></li>
  <li><a href="#individual-contributions" id="toc-individual-contributions" class="nav-link" data-scroll-target="#individual-contributions"><span class="header-section-number">10</span> Individual Contributions</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Exploring U.S. Elections and Public Opinion (1976–2020)</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Group AOS – DATA-413 </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 9, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="usage-purposes-and-overview" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="usage-purposes-and-overview"><span class="header-section-number">1</span> Usage Purposes and Overview</h2>
<p>The Shiny app, titled “Exploring U.S. Elections and Public Opinion (1976-2020), is designed for users who wish to understand how election outcomes and public opinion have changed across U.S. states from 1976-2020. Typical users may be, but are not limited to:</p>
<ul>
<li><p>Political science student</p></li>
<li><p>Policy analyst</p></li>
<li><p>Journalist or Informed citizen</p></li>
</ul>
<p>These individuals would likely wish to explore questions such as:</p>
<ul>
<li><p>How have Democratic and Republican vote shares changed across U.S. states from 1976 to 2020?</p></li>
<li><p>How has public opinion from ANES on partisanship and turnout been related to actual election results?</p></li>
<li><p>Are states with Democratic governors associated with different turnout patterns than those with Republican governors?</p></li>
<li><p>Is there a tangible relationship between Democratic presidential vote share and Democratic identification in surveys?</p></li>
</ul>
<p>The app seeks to answer these questions through four separate tabs:</p>
<ul>
<li><p><strong>A National Map Explorer Tab</strong> which visualizes the different election outcomes, partisan patterns, and voting breakdowns across the United States.</p></li>
<li><p><strong>A Single-Variable Analysis Tab</strong> for focused EDA of either ANES or election results.</p></li>
<li><p><strong>A Multi-Variable Analysis Tab</strong> which examines the different relationships between outcomes and predictors.</p></li>
<li><p><strong>A Statistical Tests Tab</strong> that features a t-test which compares turnout in states with Democratic v.s. Republican governors, a chi-square test which compares governor party v.s. presidential winning party, and a correlation test between ANES Democratic ID and Democratic vote share.</p></li>
</ul>
<p>This app is not used to answer a single question, but rather is to be utilized to provide a minimum viable product that allows users to explore and perform statistical analyses on U.S. election data.</p>
</section>
<section id="required-packages-and-environment" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="required-packages-and-environment"><span class="header-section-number">2</span> Required Packages and Environment</h2>
<p>The Shiny app uses several Shiny and visualization tools and packages:</p>
<ul>
<li><p><strong>library(dplyr)</strong> importing, cleaning, and data transformation</p></li>
<li><p><strong>library(ggplot2)</strong> graph plotting for visualization purposes</p></li>
<li><p><strong>library(readr)</strong> importing, cleaning, and data transformation</p></li>
<li><p><strong>library(readxl)</strong> importing, cleaning, and data transformation</p></li>
<li><p><strong>library(shiny)</strong> app framework and reactivity</p></li>
<li><p><strong>library(maps)</strong> for U.S. state polygons</p></li>
<li><p><strong>library(plotly)</strong> hover functionality on national map</p></li>
<li><p><strong>library(scales)</strong> formatting vote shares and turnout as percentages</p></li>
</ul>
<p>The app does work under the assumption that the R version is &gt; 4.x and latest CRAN versions of these packages as of Fall 2025 are being used. The app is structured according to class conventions, with:</p>
<ul>
<li><p><strong>data_raw/</strong> contains clean data for the app</p></li>
<li><p><strong>AOSapp.R</strong> is the main Shiny app script</p></li>
</ul>
</section>
<section id="data-sources-and-structure" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="data-sources-and-structure"><span class="header-section-number">3</span> Data Sources and Structure</h2>
<p>Our app uses the American National Election Studies (ANES) Time Series dataset. The full ANES dataset (anes_df) contains 68,224 survey responses and 1,030 variables collected across multiple election years, including respondent demographics, state information, turnout, and presidential vote choice. Additionally we incorporated from the MIT Election Data and Science Lab (MEDSL): U.S. Senate data (senate_df), which includes 3,629 observations and 19 variables; U.S. House election data (house_df), containing 33,807 observations and 20 variables; and U.S. Presidential returns (pres_df), which provide 4,287 observations and 15 variables summarizing candidate vote totals by state. We also had a a supplemental governor dataset (govener_df) was also included, with 4,600 observations and 81 variables related to state-level executive elections and characteristics such as term limits, party control, and years served. For the purposes of this Shiny application, a cleaned subset of ANES survey data was created (anes_clean_subset) by selecting relevant demographic and voting variables and filtering observations to surveys conducted from 1974 onward.</p>
</section>
<section id="running-code" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="running-code"><span class="header-section-number">4</span> Running Code</h2>
<p>The app uses three kinds of data:</p>
<ol type="1">
<li><strong>Election Results (MIT Election Data and Science Lab)</strong>
<ul>
<li><p><strong>Presidential elections (1976-2020)</strong>, state-level candidate vote totals</p></li>
<li><p><strong>U.S. Senate Elections</strong>, candidate vote totals by state</p></li>
<li><p><strong>U.S. House Elections</strong>, candidate vote totals by state and district which were cleaned into the following files:</p>
<ul>
<li><p>presidential_data_clean.csv</p></li>
<li><p>cleaned_senate_data.csv</p></li>
<li><p>house_data_cleaned.csv</p></li>
</ul></li>
</ul></li>
<li><strong>Gubernatorial Data</strong>
<ol type="1">
<li><strong>StateElections_Gub_2021_09_06_Public_Version.xlsx</strong>
<ul>
<li><p>Cleaned version contains the following variables:</p>
<ul>
<li><p>state</p></li>
<li><p>year</p></li>
<li><p>governor_party</p></li>
<li><p>femgov</p></li>
<li><p>term_length</p></li>
<li><p>gub_election</p></li>
<li><p>next_gub_election_year</p></li>
</ul></li>
</ul></li>
</ol></li>
<li><strong>Public Opinion Data (ANES Time Series)</strong>
<ol type="1">
<li><strong>anes_timeseries_cdf_csv_20220916.csv</strong> from the American National Election Studies
<ul>
<li><p>Cleaned version contains the following variables:</p>
<ul>
<li><p>State</p>
<ul>
<li>state_po (postal abbreviation), state</li>
</ul></li>
<li><p>Levels</p>
<ul>
<li>“President”, “Senate”, “House”, “Governor”</li>
</ul></li>
<li><p>Vote totals</p>
<ul>
<li>candidatevotes, totalvotes, dem_votes, rep_votes, other_votes</li>
</ul></li>
<li><p>Vote shares</p>
<ul>
<li>dem_share, rep_share, rep_margin</li>
</ul></li>
<li><p>Governor info</p>
<ul>
<li>state x year</li>
</ul></li>
<li><p>ANES summaries</p>
<ul>
<li>prop_dem_party_id, prop_rep_party_id, prop_voted</li>
</ul></li>
</ul></li>
</ul></li>
</ol></li>
</ol>
</section>
<section id="basic-structure" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="basic-structure"><span class="header-section-number">5</span> Basic Structure</h2>
<p>The app uses:</p>
<ul>
<li><p><strong>election_all_dummy:</strong> one row per candidate-state-year.</p></li>
<li><p><strong>govener_clean_sub:</strong> state-level governor characteristics.</p></li>
<li><p><strong>anes_clean_subset</strong>: individual-level ANES data with labeled factors, plus state names.</p></li>
</ul>
<p>Typical row counts:</p>
<ul>
<li><p><strong>elections_all_dummy:</strong> tens of thousands of rows.</p></li>
<li><p><strong>anes_clean_subset:</strong> tens of thousands of respondents across years.</p></li>
<li><p><strong>anes_state_year:</strong> one row per combination of (year, state) with survey aggregates.</p></li>
</ul>
</section>
<section id="exploratory-data-analysis-eda-with-the-app" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="exploratory-data-analysis-eda-with-the-app"><span class="header-section-number">6</span> Exploratory Data Analysis (EDA) with the App</h2>
<p>This section walks through the EDA workflow that the app supports and focuses on how an intended users might interact with it.</p>
<ol type="1">
<li><strong>National Map Explorer</strong></li>
</ol>
<p><img src="nat_map.png" class="img-fluid" data-fig-cap="The above screenshot is of the map tab, which is the front screen of our app.This map specifically displays the 2020 presidential election results by state, which show the Republican–Democrat geographic split with hover details showing the winning party and vote totals in each state."></p>
<pre><code>-   **Inputs:**

    -   On the **National Map Explorer Tab**, users can:

        -   choose election level (input\$map_leve):

            -   "President", "Senate", or "House"

        -   Select a year (input\$map_year)

            -   The list of years is reactive; it updates when map_level changes.

        -   Optionally filter to a single state (input\$map_state)

            -   For President maps, the default is a accumulation of all states; for other all other levels, users have the ability to isolate a singular state.

        -   Choose extra columns to show in the summary table (input\$map_info_vars)

            -   i.e. totalvotes, candidatevotes, dem_votes, rep_votes, rep_margin.

-   **Outputs:**

    -   **Interactive U.S. Map** (output\$us_map using plotlyOutput):

        -   **President:**

            -   States are colored by the winning party (Democrat, Republican, Other).

            -   Hover text shows state, winning party, Dem votes, Rep votes, and total votes.

        -   **Senate/House**

            -   States are colored by Republican - Democratic vote shares using a blue-purple-red gradient.

            -   Negative values (blue) indicate a more Democratic leaning stance; positive values (red) indicate a more Republican leaning stance.

    -   **Summary Table** (output\$map_summary)

        -   The top 20 (or less) state-year rows for the selected level and year.

        -   Includes state, state_po, year, and any user-selected map_info_vars.

    -   **Overall Winner Text** (output\$map_overall_winner) for presidential years

        -   Show the candidate and party with the most total votes in the selected year (and state, if filtered).

-   **Example Scenario:**

    -   Question: "How did the 2016 presidential map look, and which party won which states?"

        1.  Choose "President" in Election level.

        2.  Set year to 2016.

        3.  Leave state filter as "All states"

        4.  Inspect the map: states colored blue/red by winner.

        5.  Use the summary table and hover text to see vote totals in each state.</code></pre>
<ol start="2" type="1">
<li><strong>Single-Variable Analysis</strong></li>
</ol>
</section>
<section id="image" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="image"><span class="header-section-number">7</span> Image</h2>
<p>Below is a screenshot of the single variable output. The filters are set to Election results, House level election, Vote shares of Ohio. This shows the tulmotous relationship between Republicans and Democrats.</p>
<p><img src="single.png" class="img-fluid" data-fig-cap="Screenshot of the Single-Variable Analysis tab"></p>
<pre><code>-   The "Single-Variable Analysis" tab has two modes: ANES (public opinion) and Election Results

-   **Public Opinion (ANES mode)**

    -   When input\$single_analysis_data_source == "anes", the sidebar shows:

        -   **anes_variable:** which public opinion measure:

            -   **prop_voted:** turnout rate

            -   **prop_dem_party_id:** share Dem or Dem-leaning

            -   **prop_rep_party_id:** share Rep of rep-leaning

        -   **anes_filter:** demographic subset (i.e. black voters, women, high school or less)

        -   **single_analysis_year_range:** year range slider

        -   Optional state filter (if states are selected in the UI)

    -   The server:

        1.  Filters anes_clean_subset by demographic and year.
        2.  Computes a numeric "metric" for the selected variable.
        3.  Aggregates to year x state_name.
        4.  Produces a time series line plot which shows the evolution of the ANES measure by state.
        5.  Shows numerical summaries in single_analysis_summary.
        6.  Optionally displays a narrative (change in percentage points from first to last year) when the user selects "Show narrative summary".

-   **Election Results Mode**

    -   When input\$single_analysis_data_source == "results":

        -   The user selects:

            -   **single_analysis_level** – President, Senate, House, or Governor

            -   **results_metric_type** – share or winner

            -   **single_analysis_states** - up to 6 state abbreviations

            -   **single_analysis_plot_type** - time or bar

    -   The server:

        -   Filters elections_all_dummy to the chosen level and year range.

        -   Aggregates to year x state_po, computing:

            -   dem, rep, other, total, dem_share, rep_share, and winner.

        -   Plots either:

            -   vote share time series / bar chart by party and state

            -   Winning party over time (tile or bar plot of winner counts)

        -   For example:

            -   *Question:* “How has Democratic vs Republican presidential vote share changed in PA and WI since 2000?”

                1.  Data source: Election Results
                2.  Level: President
                3.  Metric type: Vote Share
                4.  States: PA, WI
                5.  Plot type: Time Series
                6.  Year range: 2000-2020

            -   The plot will show Dem/Rep vote shares across elections, faceted by state.</code></pre>
<ol start="3" type="1">
<li><strong>Multi-Variable Analysis</strong> <img src="multi.png" class="img-fluid" data-fig-cap="Above is a screenshot of our multi-Variable tab. This tab shows that as ANES-measured turnout increases, the Republican presidential vote margin generally decreases"></li>
</ol>
<p>Above is a screenshot of our multi-Variable tab. This tab shows that as ANES-measured turnout increases, the Republican presidential vote margin generally decreases.</p>
<pre><code>1.  Multi-Variable Analysis
    -   The Multi-Variable Analysis tab allows the user to explore relationships between two variables in either public opinion or election outcomes.
    -   Public Opinion (ANES mode)
    -   input\$multi_analysis_data_source == "anes”, causes the sidebar to displays: \* x_var – the ANES variable mapped to the x-axis \* y_var – the ANES variable mapped to the y-axis \* multi_analysis_filter – demographic subset (e.g., women, Black voters, low education)
    -   multi_analysis_year_range – year selection slider
    -   multi_analysis_states – optional state selection

-   The server:
    1.  Filters anes_clean_subset by the user-selected demographic and year window.
    2.  Calculates numeric rates for x_var and y_var.
    3.  Aggregates data to year × state_name
    4.  Produces a scatter plot with optional smoothing (e.g., loess line) to show association.
    5.  Displays statistical summaries, including correlation between x and y.
    6.  Provides interpretive text describing direction/strength of the relationship.
-   Example question the user can answer using this tab:
    -   “Do states with higher Democratic party identification also show higher voter turnout?”</code></pre>
<p>The resulting scatter plot shows turnout on the y-axis vs.&nbsp;Dem party ID on the x-axis, with each point representing state-level data in a given year.</p>
</section>
<section id="statistical-analysis-inputs-models-and-interpretation" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="statistical-analysis-inputs-models-and-interpretation"><span class="header-section-number">8</span> Statistical Analysis: Inputs, Models, and Interpretation</h2>
<p>The <strong>Statistical Tests</strong> tab lets users run three pre-defined analyses that link election results and public opinion.</p>
<ul>
<li><p><strong>User controls:</strong></p>
<ul>
<li><p>Choose a test:</p>
<ul>
<li><p>Turnout by governor party (t-test)</p></li>
<li><p>Governor vs.&nbsp;president party alignment (chi-square)</p></li>
<li><p>ANES Democratic ID vs.&nbsp;Democratic vote share (correlation)</p></li>
</ul></li>
<li><p>Select a <strong>year range</strong> with a slider</p>
<ul>
<li><p>For the turnout–governor-party t-test, the app automatically restricts the data to <strong>2001 and later</strong></p></li>
<li><p>For the other tests, the app uses the chosen range but caps the maximum at the <strong>last year with data</strong></p></li>
</ul></li>
</ul></li>
<li><p><strong>Behind the scenes</strong></p>
<ul>
<li><p>Filters data to valid years and state–year combinations</p></li>
<li><p>Runs:</p>
<ul>
<li><p>A two-sample t-test comparing average ANES turnout by governor party</p></li>
<li><p>A chi-square test of independence between governor party and presidential winning party</p></li>
<li><p>A Pearson correlation between ANES Democratic ID and Democratic vote share</p></li>
</ul></li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><p>The formal test result (test statistic, p-value, and, when relevant, confidence interval)</p></li>
<li><p>A small table showing the first rows of the data used in the test, so users can see exactly what observations went into the analysis</p></li>
</ul></li>
</ul>
</section>
<section id="literature-review-sources" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="literature-review-sources"><span class="header-section-number">9</span> Literature Review (Sources)</h2>
<p><strong>References</strong></p>
<p>Hill, K. Q. (2013). <em>Analyzing purple state trends in U.S. presidential elections (1976–2020).</em> University of Georgia OpenScholar.</p>
<p>Lublin, D. (2013). <em>Battleground states and voter participation in U.S. presidential elections: An empirical test.</em></p>
<p>McKee, S., &amp; Teigen, J. (2013). <em>Swing state voter behavior and mobilization.</em> ScholarWorks at University of Maine.</p>
<p>MIT Election Data and Science Lab. (2021). <em>U.S. president 1976–2020 county and state election returns.</em></p>
<p>U.S. Election Assistance Commission. (2011). <em>The Electoral College.</em></p>
<p>Warshaw, C. (2020). Local elections and representation in the United States. <em>Annual Review of Political Science, 23,</em> 151–170. foodies</p>
</section>
<section id="individual-contributions" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="individual-contributions"><span class="header-section-number">10</span> Individual Contributions</h2>
<ol type="1">
<li><strong>Syd Affolter:</strong>
<ol type="1">
<li>Basic app outline;</li>
<li>Map tab;</li>
<li>Contributor Progress Report;</li>
<li>ReadMe;</li>
<li>Contributor Multi-Variable tab;</li>
</ol></li>
<li><strong>Amal Abdi:</strong>
<ol type="1">
<li>Single-Variable tab;</li>
<li>Progress Plan</li>
<li>Cleaned ANES and governor data;</li>
<li>Contributor Multi-Variable tab;</li>
<li>Contributor Progress Report;</li>
</ol></li>
<li><strong>Olivia Bohart</strong>
<ol type="1">
<li>Statistical Analysis tab;</li>
<li>Cleaned senate, president, house data;</li>
<li>Contributor Multi-Variable tab;</li>
<li>Contributor Progress Report;</li>
<li>Vignette;</li>
</ol></li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>